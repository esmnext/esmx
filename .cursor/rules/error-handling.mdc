
# é”™è¯¯å¤„ç†è§„èŒƒ

## âŒ ä¸¥æ ¼é™åˆ¶ try-catch ä½¿ç”¨
- **é¿å…æ»¥ç”¨**ï¼šç¦æ­¢"å†™ä¸€æ®µä»£ç å°±åŒ…ä¸€ä¸ª try-catch"çš„ä¹ æƒ¯
- **å¼ºæ­£å½“æ€§è¦æ±‚**ï¼šæ¯æ¬¡ä½¿ç”¨ try-catch éƒ½å¿…é¡»æœ‰å……åˆ†çš„æ­£å½“ç†ç”±
- **ä¼˜å…ˆ Result æ¨¡å¼**ï¼šç»å¤§å¤šæ•°æƒ…å†µä¸‹ä½¿ç”¨ Result æ¨¡å¼å¤„ç†é”™è¯¯
- **è¾¹ç•Œå±‚ä½¿ç”¨**ï¼štry-catch ä¸»è¦ç”¨äºåº”ç”¨è¾¹ç•Œå±‚å’Œå·¥å…·å‡½æ•°å°è£…
- **ç¦æ­¢é™é»˜å¤„ç†**ï¼šä¸¥ç¦åœ¨ catch å—ä¸­é™é»˜å¿½ç•¥é”™è¯¯

## âœ… Result æ¨¡å¼ï¼ˆæ¨èï¼‰
```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Recommended error handling approach
const processUser = async (userData: unknown): Promise<Result<User, ValidationError>> => {
  if (!userData || typeof userData !== 'object') {
    return { 
      success: false, 
      error: new ValidationError('Invalid user data format') 
    };
  }
  
  const validationResult = validateUserData(userData);
  if (!validationResult.success) {
    return validationResult;
  }
  
  return { success: true, data: validationResult.data };
};
```

## ğŸ“ try-catch åˆç†ä½¿ç”¨åœºæ™¯

**å…è®¸ä½¿ç”¨ try-catch çš„æ­£å½“ç†ç”±**ï¼š

### 1. å·¥å…·å‡½æ•°å°è£…
åŒ…æ‹¬å®‰å…¨æ“ä½œå‡½æ•°å’Œ Result æ¨¡å¼é€‚é…å™¨ï¼š

```typescript
// âœ… Valid use: Wrapping lower-level APIs into Result pattern
export const safeJsonParse = <T>(jsonString: string): Result<T, Error> => {
  try {
    const parsed = JSON.parse(jsonString);
    return { success: true, data: parsed };
  } catch (error) {
    return { success: false, error: error as Error };
  }
};

export const safeDbOperation = async <T>(
  operation: () => Promise<T>
): Promise<Result<T, Error>> => {
  try {
    const result = await operation();
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error as Error };
  }
};

// âœ… Safe getter operations - allowed to return null
export const getUserById = async (id: string): Promise<User | null> => {
  const dbResult = await safeDbOperation(() => db.user.findById(id));
  return dbResult.success ? dbResult.data : null;
};

export const getConfigValue = async (key: string): Promise<string | null> => {
  const configResult = await safeReadFile('config.json');
  if (!configResult.success) {
    return null;
  }
  
  const parseResult = safeJsonParse<Record<string, string>>(configResult.data);
  if (!parseResult.success) {
    return null;
  }
  
  return parseResult.data[key] || null;
};

// âœ… Safe query operations
export const findUserByEmail = async (email: string): Promise<User | null> => {
  const result = await safeDbOperation(() => db.user.findByEmail(email));
  return result.success ? result.data : null;
};
```

**å®‰å…¨æ“ä½œå‡½æ•°ç‰¹å¾**ï¼š
- å‡½æ•°åé€šå¸¸ä»¥ `get`ã€`find`ã€`fetch` å¼€å¤´
- è¿”å›ç±»å‹ä¸º `T | null`
- å¤±è´¥æ—¶ä¸ä¼šå½±å“ä¸»è¦ä¸šåŠ¡æµç¨‹
- è°ƒç”¨æ–¹å¯ä»¥å®‰å…¨åœ°å¤„ç† `null` å€¼

### 2. åº”ç”¨è¾¹ç•Œå±‚
```typescript
// âœ… Valid use: Unified error handling at application boundary
const handleApiRequest = async (req: Request, res: Response) => {
  try {
    const result = await processUserRequest(req.body);
    
    if (!result.success) {
      const statusCode = getErrorStatusCode(result.error);
      res.status(statusCode).json({
        error: result.error.message,
        code: result.error.code
      });
      return;
    }
    
    res.json(result.data);
  } catch (error) {
    // Catch unexpected system-level errors
    console.error('Unexpected system error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
```

### 3. ç¬¬ä¸‰æ–¹åº“é€‚é…
```typescript
// âœ… Valid use: Adapting third-party libraries that don't support Result pattern
const adaptThirdPartyApi = async (params: ApiParams): Promise<Result<ApiResponse, Error>> => {
  try {
    // Third-party library may throw exceptions, need adaptation
    const response = await thirdPartyLibrary.callApi(params);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: error as Error };
  }
};
```

### 4. èµ„æºæ¸…ç†åœºæ™¯
```typescript
// âœ… Valid use: Ensuring resource cleanup
const processFileWithCleanup = async (filePath: string): Promise<Result<ProcessedData, Error>> => {
  let fileHandle: FileHandle | null = null;
  
  try {
    fileHandle = await fs.open(filePath, 'r');
    const result = await processFileHandle(fileHandle);
    return result;
  } catch (error) {
    return { success: false, error: error as Error };
  } finally {
    // Ensure resources are cleaned up
    if (fileHandle) {
      await fileHandle.close();
    }
  }
};
```

## âŒ ç¦æ­¢çš„ try-catch ä½¿ç”¨

### 1. ä¸šåŠ¡é€»è¾‘ä¸­çš„æ‡’æƒ°åŒ…è£…
```typescript
// âŒ Forbidden: Lazily wrapping every piece of code
const createUser = async (userData: any) => {
  try {
    const user = await userService.create(userData);
    return user;
  } catch (error) {
    console.log('Error creating user:', error);
    return null; // Silent failure, hiding problems
  }
};
```

### 2. é™é»˜é”™è¯¯å¤„ç†
```typescript
// âŒ Forbidden: Silently ignoring errors
const fetchUserData = async (id: string) => {
  try {
    return await api.getUser(id);
  } catch (error) {
    return {}; // Silent return of empty object, hiding failure
  }
};
```

### 3. è¿‡åº¦åµŒå¥—çš„é”™è¯¯å¤„ç†
```typescript
// âŒ Forbidden: Wrapping every operation with try-catch
const complexOperation = async () => {
  try {
    const step1 = await operation1();
    try {
      const step2 = await operation2(step1);
      try {
        return await operation3(step2);
      } catch (error3) {
        console.log('Step 3 failed');
        return null;
      }
    } catch (error2) {
      console.log('Step 2 failed');
      return null;
    }
  } catch (error1) {
    console.log('Step 1 failed');
    return null;
  }
};
```

## é”™è¯¯å¤„ç†ç­–ç•¥
- **ç¦æ­¢å‡è£…æˆåŠŸ**: æ‰§è¡Œå¤±è´¥äº†ä¸èƒ½å‡è£…æˆåŠŸï¼Œè¦æ ¹æ®ä¸šåŠ¡æƒ…å†µæ­£ç¡®å¤„ç†
- **æ˜¾å¼å¤„ç†**: æ¯ä¸ªå¯èƒ½å¤±è´¥çš„æ“ä½œéƒ½å¿…é¡»æ˜¾å¼æ£€æŸ¥Result
- **æ—©æœŸè¿”å›**: ä½¿ç”¨æ—©æœŸè¿”å›å¤„ç†é”™è¯¯æ¡ä»¶ï¼Œé¿å…æ·±å±‚åµŒå¥—
- **é”™è¯¯ä¼ æ’­**: è®©é”™è¯¯å‘ä¸Šä¼ æ’­åˆ°èƒ½å¤Ÿå¤„ç†çš„è¾¹ç•Œå±‚
- **ç±»å‹å®‰å…¨**: ä½¿ç”¨å…·ä½“çš„é”™è¯¯ç±»å‹ï¼Œæä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
- **æ­£å½“æ€§æ£€æŸ¥**: try-catch ä½¿ç”¨å‰å¿…é¡»ç¡®è®¤æœ‰å……åˆ†çš„æ­£å½“ç†ç”±

## ä¸¥æ ¼çš„é”™è¯¯æµç¨‹æ§åˆ¶
**æ ¸å¿ƒåŸåˆ™**: æ‰§è¡Œå¤±è´¥äº†ä¸èƒ½å‡è£…æˆåŠŸï¼Œè¦æ ¹æ®ä¸šåŠ¡æƒ…å†µæ­£ç¡®å¤„ç†é”™è¯¯ã€‚

### æ–‡ä»¶æ“ä½œç¤ºä¾‹
```typescript
// âŒ Forbidden approach - Abusing try-catch
try {
  const content = await fs.readFile('config.json', 'utf-8');
  return JSON.parse(content);
} catch (error) {
  console.log('File read failed, using default config');
  return defaultConfig; // Error: Continue execution after failure
}

// âœ… Correct approach - Result pattern + early return
const readConfigFile = async (filePath: string): Promise<Result<Config, FileError>> => {
  // Use file reading tools that support Result pattern
  const fileResult = await safeReadFile(filePath);
  if (!fileResult.success) {
    return { success: false, error: new FileError('Failed to read config file', filePath) };
  }
  
  const parseResult = safeJsonParse<Config>(fileResult.data);
  if (!parseResult.success) {
    return { success: false, error: new FileError('Invalid JSON in config file', filePath) };
  }
  
  return { success: true, data: parseResult.data };
};

// Caller must explicitly handle errors
const initializeApp = async (): Promise<Result<App, InitError>> => {
  const configResult = await readConfigFile('config.json');
  if (!configResult.success) {
    // Return immediately on error, never continue execution
    return { success: false, error: new InitError('Config loading failed', configResult.error) };
  }
  
  // Only continue when successful
  return createApp(configResult.data);
};
```

### ç½‘ç»œè¯·æ±‚ç¤ºä¾‹
```typescript
// âŒ Forbidden approach
try {
  const response = await fetch('/api/users');
  const users = await response.json();
  return users;
} catch (error) {
  return []; // Error: Return empty array after failure and continue execution
}

// âœ… Correct approach
const fetchUsers = async (): Promise<Result<User[], NetworkError>> => {
  const response = await safeFetch('/api/users');
  if (!response.success) {
    return { success: false, error: new NetworkError('Failed to fetch users', response.error) };
  }
  
  if (!response.data.ok) {
    return { 
      success: false, 
      error: new NetworkError(`HTTP ${response.data.status}: ${response.data.statusText}`) 
    };
  }
  
  const jsonResult = await safeJsonParse<User[]>(await response.data.text());
  if (!jsonResult.success) {
    return { success: false, error: new NetworkError('Invalid JSON response', jsonResult.error) };
  }
  
  return { success: true, data: jsonResult.data };
};
```

### æ•°æ®åº“æ“ä½œç¤ºä¾‹
```typescript
// âŒ Forbidden approach
try {
  const user = await db.user.create(userData);
  return user;
} catch (error) {
  console.error('Database error:', error);
  return null; // Error: Return null after failure and continue execution
}

// âœ… Correct approach
const createUser = async (userData: CreateUserData): Promise<Result<User, DatabaseError>> => {
  const validationResult = validateUserData(userData);
  if (!validationResult.success) {
    return { success: false, error: new DatabaseError('Validation failed', validationResult.error) };
  }
  
  const dbResult = await safeDbOperation(() => db.user.create(validationResult.data));
  if (!dbResult.success) {
    return { success: false, error: new DatabaseError('Failed to create user', dbResult.error) };
  }
  
  return { success: true, data: dbResult.data };
};
```

## è‡ªå®šä¹‰é”™è¯¯ç±»å‹
```typescript
export class ValidationError extends Error {
  constructor(
    message: string, 
    public readonly field: string,
    public readonly code: string
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class FileError extends Error {
  constructor(
    message: string,
    public readonly filePath: string,
    public readonly originalError?: Error
  ) {
    super(message);
    this.name = 'FileError';
  }
}

export class NetworkError extends Error {
  constructor(
    message: string,
    public readonly originalError?: Error
  ) {
    super(message);
    this.name = 'NetworkError';
  }
}

export class DatabaseError extends Error {
  constructor(
    message: string,
    public readonly originalError?: Error
  ) {
    super(message);
    this.name = 'DatabaseError';
  }
}
```

## å·¥å…·å‡½æ•°ç¤ºä¾‹
```typescript
// Safe file reading
export const safeReadFile = async (filePath: string): Promise<Result<string, Error>> => {
  return new Promise((resolve) => {
    fs.readFile(filePath, 'utf-8', (err, data) => {
      if (err) {
        resolve({ success: false, error: err });
      } else {
        resolve({ success: true, data });
      }
    });
  });
};

// Safe JSON parsing
export const safeJsonParse = <T>(jsonString: string): Result<T, Error> => {
  let parsed: T;
  try {
    parsed = JSON.parse(jsonString);
  } catch (error) {
    return { success: false, error: error as Error };
  }
  return { success: true, data: parsed };
};

// Safe database operations
export const safeDbOperation = async <T>(
  operation: () => Promise<T>
): Promise<Result<T, Error>> => {
  let result: T;
  try {
    result = await operation();
  } catch (error) {
    return { success: false, error: error as Error };
  }
  return { success: true, data: result };
};
